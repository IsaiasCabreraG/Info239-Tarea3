
# Protocolo Parada y Espera (Stop-and-Wait) con Sockets en Python

## üìù Descripci√≥n General

Este proyecto implementa una variante del **protocolo Stop-and-Wait**, un esquema fundamental para la transmisi√≥n de datos confiable en redes de comunicaci√≥n. Su objetivo principal es asegurar la **entrega confiable, ordenada y segura de la informaci√≥n**, incluso frente a problemas comunes en el medio de transmisi√≥n como la p√©rdida o corrupci√≥n de paquetes.

El protocolo Stop-and-Wait se eligi√≥ por su **simplicidad y robustez**, permitiendo que el emisor env√≠e una √∫nica trama y espere una confirmaci√≥n (ACK o NAK) del receptor antes de proceder con el siguiente paquete. La implementaci√≥n se realiza utilizando **sockets TCP en Python**, lo que facilita la comunicaci√≥n bidireccional entre las entidades de emisor y receptor.

## ‚ú® Caracter√≠sticas Principales

*   **Control de Flujo Stop-and-Wait**: El emisor env√≠a un paquete y detiene la transmisi√≥n hasta recibir una confirmaci√≥n del receptor. Solo se env√≠a una trama a la vez.
*   **Manejo de Errores Robustos**:
    *   **N√∫meros de Secuencia**: Cada paquete de datos incluye un n√∫mero de secuencia de 1 byte que se incrementa secuencialmente, permitiendo la **identificaci√≥n √∫nica y la detecci√≥n de paquetes duplicados**. Los paquetes de confirmaci√≥n tambi√©n llevan el n√∫mero de secuencia del paquete al que responden para asegurar la sincronizaci√≥n.
    *   **Checksum CRC-16-IBM**: Utilizado tanto en paquetes de datos como de confirmaci√≥n para **detectar errores de transmisi√≥n**. Si el CRC es incorrecto, el paquete se considera da√±ado.
    *   **Confirmaciones ACK/NAK**: El receptor env√≠a un ACK (confirmaci√≥n positiva) si el paquete es correcto y esperado, o un NAK (confirmaci√≥n negativa) si detecta un error (CRC incorrecto).
    *   **Temporizador (Timeout)**: El emisor inicia un temporizador al enviar cada paquete. Si no recibe una confirmaci√≥n v√°lida antes de que el temporizador expire, asume una p√©rdida y **reenv√≠a el paquete**.
*   **Seguridad B√°sica con Cifrado XOR**: Los 3 bytes de datos √∫tiles dentro de cada paquete son cifrados mediante una **operaci√≥n XOR con una clave sim√©trica predefinida** (`0x12`). Este m√©todo es ligero y de implementaci√≥n sencilla, aunque con limitaciones en robustez.
*   **Estructura de Paquetes Definida**:
    *   **Paquete de Datos (7 bytes)**:
        *   `N¬∞ de secuencia` (1 byte).
        *   `Datos` (3 bytes, cifrados con XOR).
        *   `Fin de mensaje` (1 byte, indica el √∫ltimo fragmento).
        *   `Checksum` (2 bytes, CRC-16-IBM).
    *   **Paquete de Confirmaci√≥n (4 bytes)**:
        *   `N¬∞ de secuencia confirmado` (1 byte).
        *   `Tipo de confirmaci√≥n` (1 byte: 1 para ACK, 0 para NAK).
        *   `Checksum` (2 bytes, CRC-16-IBM).
*   **Simulaci√≥n de Errores**: El c√≥digo incluye funciones (`envioConError` en emisor y receptor) que simulan **p√©rdida de paquetes, env√≠o repetido y corrupci√≥n de bits** con probabilidades configurables, para probar la robustez del protocolo.

## üö¶ Funcionamiento y Manejo de Errores

El protocolo maneja diversas situaciones para asegurar la entrega correcta de los datos:

*   **Env√≠o Normal**: El emisor env√≠a un paquete, el receptor lo recibe, verifica (CRC y secuencia), descifra los datos y env√≠a un ACK. El emisor recibe el ACK y procede con el siguiente paquete.
*   **P√©rdida de Paquete en el Medio**: Si un paquete se pierde, el emisor no recibe la confirmaci√≥n dentro del tiempo establecido por el temporizador. Esto provoca que el **emisor reenv√≠e el paquete**.
*   **Errores en el Paquete de Datos (Corrupci√≥n)**: Si una trama llega da√±ada (por ejemplo, un bit cambiado), el receptor detecta el error al verificar el **CRC-16-IBM**. En este caso, el receptor **desecha el paquete y env√≠a un NAK**. El emisor, al recibir el NAK, reenv√≠a la trama.
*   **Errores o P√©rdida en la Confirmaci√≥n (ACK/NAK)**:
    *   Si la confirmaci√≥n se corrompe (CRC incorrecto) o se pierde, el emisor no recibir√° un ACK v√°lido o su temporizador expirar√°. En ambos casos, el emisor **reenv√≠a el paquete original**.
    *   Si el receptor recibe un **paquete duplicado** (debido a un reenv√≠o por un timeout prematuro o p√©rdida de ACK), lo identifica mediante el n√∫mero de secuencia. El receptor **descarta el duplicado y reenv√≠a el ACK** para el paquete que ya hab√≠a procesado correctamente.

## üöÄ C√≥mo Ejecutar el Proyecto

Para ejecutar este protocolo, necesitas tener Python instalado en tu sistema.

### ‚öôÔ∏è Prerrequisitos

*   Python (versi√≥n 3.x recomendada)

### üíª Pasos de Ejecuci√≥n

1.  **Clonar el Repositorio (o descargar los archivos):**
    ```bash
    git clone <URL_DEL_REPOSITORIO>
    cd <NOMBRE_DEL_REPOSITORIO>
    ```
2.  **Iniciar el Receptor:**
    Abre una terminal y ejecuta el script del receptor:
    ```bash
    python receptor.py
    ```
    El receptor se iniciar√° y esperar√° una conexi√≥n entrante en el puerto `12345`.
3.  **Iniciar el Emisor:**
    Abre otra terminal (o tab) y ejecuta el script del emisor:
    ```bash
    python emisor.py
    ```
    El emisor intentar√° conectarse al receptor. Una vez conectado, comenzar√° a enviar el mensaje dividido en paquetes, mostrando el proceso y los eventos de error simulados.


## üë• Autores

Este proyecto fue desarrollado por los siguientes integrantes:

*   Mart√≠n Alvarado Balboa
*   Isa√≠as Cabrera Gauna
*   Osvaldo Casas-Cordero Navarro
*   Andr√©s Mardones Domcke

---